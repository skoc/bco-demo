{
  "bco_spec_version": "https://w3id.org/biocompute/1.3.0/",
  "bco_id": "http://biocompute.sbgenomics.com/bco/4dfbb8f7-4f3e-49af-96e2-6d633ee82b5c",
  "checksum": "4d33c558d28c31a361dd5e3462dcd689165e73ba41b0108f57719b049c22e645",
  "provenance_domain": {
    "name": "gral-0.14.3",
    "version": "1.0.0",
    "review": [],
    "derived_from": "https://api.sbgenomics.com/v2/apps/soner/bco-demo/gral-0-14-3/0/raw/",
    "obsolete_after": "2019-09-04T00:00:00+0000",
    "embargo": ["2019-09-04T00:00:00+0000", "2019-09-04T00:00:00+0000"],
    "created": "2019-09-04T00:00:00+0000",
    "modified": "2019-09-04T00:00:00+0000",
    "contributors": [],
    "license": "https://spdx.org/licenses/CC-BY-4.0.html"
  },
  "usability_domain": "# Version\n**aligner**\n + **class**: graph aligner\n + **name**: aligner\n + **version**: 0.14.3\n\n**ggeco search engine**\n + **class**: ggeco search engine\n + **version**: 2.03.03\n + **version name**: Mycroft\n\n# Seven Bridges Graph Aligner\n\nGraph Aligner is a fast and accurate read aligner that works on Genome Graphs. Genome Graphs are usually constructed from, but not limited to, a linear reference plus a VCF file containing known variants.\n\nBriefly, the alignment algorithm works as follows. For each read (pair if PE):\n\n * A global search is performed to identify candidate regions (seeds)\n * A fast but gapless alignment algorithm allowing configurable number of mismatches is used to find an alignment for each seed\n * If a gapless alignment wasn't found for a seed, a slower but gappy alignment algorithm is tried\n * Among all possible alignments found from seeds, best one is chosen: For SE, alignment with the best score. For PE, proper pair with the highest total score, unless the unpaired total score is higher with a margin more than `unpaired_penalty`.\n * Graph alignment is projected onto linear reference and written to BAM file\n\n## 1 Usage\n\n```\n  aligner options\n```\n\n### 1.1 Input/Output Options\n\n|**option**|**description**|\n|-|-|\n|`in_graph <.gg>`|Input graph in binary format|\n|`reference <.fasta, .fasta.gz, .fa, .fa.gz>`|Reference genome|\n|`vcf <.vcf, .vcf.gz, .bcf>`|Variations for graph|\n|`fastq <.fastq, .fastq.gz, .fq, .fq.gz>`|Single end FASTQ or first end FASTQ of a paired end experiment|\n|`fastq2 <.fastq, .fastq.gz, .fq, .fq.gz>`|Second end FASTQ of a paired end experiment|\n|`interleaved_FQ`|Treat single FASTQ input as interleaved paired end input|\n|`base_quality_threshold <INT>`|Quality threshold for bases considered for alignment. If <1/3 of the read is below the threshold it will be skipped. If negative, a statistic estimate based on the first 1000 reads will be employed for the calculation.|\n|`n_reads <INT>`|# of reads (pairs if PE) to process from fastq.|\n|`skip_reads <INT>`|# of reads (pairs if PE) to skip from fastq, zero-based. Usage: `n 1000 -N 100`; processing the reads/pairs `[1000,1100)`.|\n|`prefix_filter <STR>`|Only process reads (pairs if PE) with the given prefix|\n  |`out_graph <.gg>`|Save the graph in binary format|\n|`uncompressed`|Output an uncompressed BAM|\n|`output <.bam>`|Output BAM file path, `stdout` should be given to write to standard output|\n|`disable_graph_bam_tags`|Don't write graph BAM tags (XA, XB, XG, XM).|\n|`debugging_tags`|Write debugging tags (YG, Yg, YI, Yi, YA).|\n|`read_group_unit <STR>`|Read group unit|\n|`read_group_library <STR>`|Read group library|\n|`read_group_platform <STR>`|Sequence platform of reads. Valid values are `CAPILLARY, LS454, ILLUMINA, SOLID, HELICOS, IONTORRENT, ONT, and PACBIO`. Default: `ILLUMINA`|\n|`read_group_id <STR>`|Read group id for reads. Default: a random string.|\n|`read_group_sample <STR>`|Sample name for reads. Default: a random string.|\n\n\n*Notes*:\n\n* Links for file format specifications: [FASTA][fasta_spec], [FASTQ][fastq_spec], [VCF/BCF][vcf_spec], [SAM/BAM][sam_spec]\n* Input graph can be provided either by `in_graph` option with a binary graph format or by using `fasta` in combination with `vcf`. Omitting `vcf` will result in aligning onto linear reference. `in_graph` and `reference` optuins are mutually exclusive.\n* Generated graph can also be outputted in binary format with `out_graph` option.\n* `read_group_unit`, `read_group_library`, `read_group_platform`, `read_group_id` and `read_group_sample` are written to BAM as a header (`PU`, `LB`, `PL`, `ID` and `SM` under `@RG` respectively). On platform, if these values are present in file metadata, APP will automatically supply them.\n* `read_group_id` is also written as `RG` tag for individual reads. If it is not provided, a random string will be generated.\n* `interleaved_FQ` will use a single FASTQ file as paired end input (`fastq`) where reads are interleaved.\n* `uncompressed` will output a BAM with no compression. This is used in addition to `output stdout` to enable sorting with `sambamba` as a pipe operation.\n* See [BAM Tags](#bam-tags) section for what is controlled by `disable_graph_bam_tags` and `debugging_tags`.\n\n[fasta_spec]: https://en.wikipedia.org/wiki/FASTA_format\n[fastq_spec]: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2847217/#__sec7title\n[vcf_spec]: https://github.com/samtools/hts-specs/blob/master/VCFv4.3.pdf\n[sam_spec]: https://samtools.github.io/hts-specs/SAMv1.pdf\n\n### 1.2 Global Search Engine Options\n\n|**option**|**description**|\n|-|-|\n|`hash_table_size_log2 <{16-32}>`|Index hash table size. If 0, set to an optimal value based upon hash parameters and graph size. Default: 30|\n|`hash_block_step <{1-14}>`|k-mer interval for index. Default: 7|\n|`hash_block_size <{8-28}>`|k-mer size for index. Default: 21|\n|`max_match_list_size_deviation <DOUBLE>`|Hash block threshold for index. Frequent hashes above this threshold will be removed. Default: 500|\n|`desired_min_number_of_matches <INT>`|Estimated hash hits per hash_block_step to find candidate regions. Default: 4 (SE) and 20 (PE)|\n\n*Notes*:\n\n* Reference indexing is performed with k-mers of size `hash_block_size` (default: 21) with intervals of `hash_block_step` (default: 7).\n* Search engine removes hash entries if a particular hash is observed too often in the reference, since common k-mers are not very informative. `max_match_list_size_deviation` controls the threshold where this happens.\n* Search engine will perform search in steps prioritizing unique hits first rather than all possible hit locations. `desired_min_number_of_matches` defines a threshold where the better (small list) hits are estimated to return a candidate region. If it fails, search engine will fall back to all possible hits for searching candidate regions.\n* See [this document][ggeco_parameters] for a more detailed explanation of these parameters.\n\n[ggeco_parameters]: https://docs.google.com/document/d/1ENFMLINLEhtGNjNZ1bfb-p0xlCrmRtvDgB1Xq7sm2xY/edit\n\n### 1.3 Local Alignment Options\n\n|**option**|**description**|\n|-|-|\n|`no_local_aligner`|Disable local aligner. If set, running global search only along with `debugging_tags` will see global search results in YG tags.|\n|`request_seeds <INT>`|# to request for MQ calculation. Default: `250`|\n|`hash_short_list <INT>`|# of global search hits that the local aligner will investigate. Default: `50`|\n|`disable_glia`|Don't use GLIA in local alignment.|\n|`disable_bpa`|Don't use BPA in local alignment.|\n|`min_mismatches <INT>`|Minimum number of allowed mismatches. Maximum value from this and percent_mismatches will be used. Default: 3|\n|`percent_mismatches <INT>`|Percent of allowed mismatches relative to read length, after truncating bad bases. Maximum value from this and min_mismatches will be used. Default: 3|\n|`min_glia_score <INT>`|Minimal SW score. Default: `Read length/3`.|\n|`glia_score_extend_gap <INT>`|Smith-Waterman extending gaps score. Default: 1|\n|`glia_score_open_gap <INT>`|Smith-Waterman opening a gap score. Default: 6|\n|`glia_score_mismatch <INT>`|Smith-Waterman mismatch score. Default: 4|\n|`glia_score_match <INT>`|Smith-Waterman match score. Default: 1|\n|`glia_scores <STR>`|Comma-separated list of GLIA scores: match,mismatch,open gap,extend gap|\n|`unpaired_penalty <INT>`|The penalty of a unpaired read. Default: `17`.|\n|`insert_length <INT>`|Insert length for paired-end reads. If not specified, will be estimated based on the first 10,000 read pairs.|\n|`insert_length_sd <INT>`|Standard deviation of insert length for paired-end reads. If not specified, and insert length is specified, will be set to `insert length / 4`. Otherwise will be estimated from the the first 10,000 read pairs.|\n\n*Notes*:\n\n* `insert_length` and `insert_length_sd` are used in both global search windows and compatibility calculations (i.e. deciding if a pair alignment is proper)\n* `min_mismatches` and `percent_mismatches` configures the allowed maximum mismatches for the gapless alignment algorithm. The maximum of the two values will be picked. If you want to give a fixed value, set it with `min_mismatches` and specify `0` for `percent_mismatches`\n* `unpaired_penalty` is the penalty applied to unpaired alignments for paired end reads. A proper pair is forced if maximum paired score is lower than the maximum unpaired score up to this penalty. Otherwise unpaired alignments are outputted.\n\n\n### 1.4 Other\n\n|**option**|**description**|\n|-|-|\n|`threads <INT>`|# of running threads.|\n|`help`|help|\n|`version`|Displays version information and exits.|\n|`version_json`|Output a json representation of the version information.|\n\n*Notes*:\n\n## 2 BAM tags\n\n### 2.1 Alignment Tags\n\nThe following tags are set for all reads.\n\n  - **`NM`**: Number of mismatches against the reference.\n  - **`YQ`**: The Smith-Waterman score of the alignment.\n  - **`Yq`**: The suboptimal Smith-Waterman score (i.e. the best Smith-Waterman score for the potential alignments not selected).\n  - **`UQ`**: The quality score associated with the seed used in alignment by global search.\n\n### 2.2 Graph Alignment Tags\n\nThe following tags are added to each read for graph-related information:\n\n - **`XA`**: The start locus in the graph relative to the position of the reference alignment on the backbone. This tag is only present if the start locus is not on the linear reference.\n - **`XB`**: The path of the alignment from the start locus. This tag is only present if the alignment takes a non-primary path.\n - **`XG`**: The cigar describing the alignment of the read against the graph path. This tag is only present if the alignment path contains at least one edge that is not on the backbone, or the graph alignment has at least one mismatch.\n - **`XM`**: The number of mismatches against the graph. The tag is only present if that number is different from the mismatches against the reference.\n\nMore details can be found in the [Graph Alignment Tag Specification][tag_spec].\n\n[tag_spec]: https://sbgdinc.atlassian.net/wiki/spaces/GRAPH/pages/696510/Graph+Alignment+Tags+for+SAM+BAM+format.\n\n### 2.3 Debugging Tags\n\nThe following tags are only included if `debugging_tags` is used.\n\n  - **`YG`**: List of seeds produced by global search. The tag is not present if global search found no seeds.\n  - **`Yg`**: Equivalent to YG for the read's mate.\n  - **`YI`**: Index of the seed in the global search seeds used to produce the selected alignment.\n  - **`Yi`**: Equivalent to YI for the read's mate.\n  - **`YA`**: Algorithm used for the alignment. A value of 1 indicates BPA and 2 indicates GLIA.\n\n## 3 Usage Examples\n\n* Loading reference from `FASTA` and `VCF`:\n\n    ```\n    aligner --reference reference.fasta --vcf variants.vcf [...]\n    ```\n\n* Loading reference from a binary graph file:\n\n    ```\n    aligner --in_graph graph.gg [...]\n    ```\n\n    *Note*: Binary graphs can be created in multiple ways but aligner requires edge projection metadata present. Graphs generated directly with `aligner` via `out_graph` option or through [ReferenceGraph][reference_graph] tools (`graph_builder` or with `python` bindings) will work. Alternatively, you can use [ggeco][ggeco] to create/inspect/visualize the graphs.\n\n* Single-end alignment\n\n    ```\n    aligner --reference ref.fasta --vcf var.vcf --fastq single-end.fastq --output output.bam [...]\n    ```\n\n* Paired-end alignment\n\n    ```\n    aligner --reference ref.fasta --vcf var.vcf --fastq pair-1.fastq --fastq2 pair-2.fastq --output output.bam [...]\n    ```\n\n* Paired-end interleaved FASTQ\n\n    ```\n    aligner --reference ref.fasta --vcf var.vcf --fastq pair-interleaved.fastq --interleaved_FQ --output output.bam [...]\n    ```\n\n* Piped sorting using [sambamba][sambamba]\n\n    ```\n    aligner [...] --output stdout --uncompressed [...] | sambamba sort [...] -o output.bam /dev/stdin\n    ```\n\n    *Note*: `uncompressed` isn't strictly necessary but it would help with sorting since no decompression will be needed while reading.\n\n[reference_graph]: https://gitlab.sbgsbgd.com/GraphGenome/ReferenceGraph\n[ggeco]: https://gitlab.sbgsbgd.com/GraphGenome/ggeco\n[sambamba]: http://lomereiter.github.io/sambamba/\n\n## 4 Notes on Behavior\n\n### 4.1 Memory\n\nIndexing a whole human genome with a `VCF` containing ~15 million variants takes about 20GB of memory\n\n### 4.2 Speed\n\nAligning 50x coverage paired end reads on whole human genome takes about 7h with 36 cores.\n\n### 4.3 Search Index Parameters\n\nDefaults for search engine are optimized for human genome with 100-150bp long reads. Depending on your data, you might want different options.\n\n* One obvious choice will be `hash_block_size` and `hash_block_step`. These will determine the k-mer size and interval used for indexing. Smaller steps will allow the engine to index with a better resolution. Note that this will result in more hits and may slow the performance. Block size is length of k-mer used for exact match searching. Depending on the error profile of the reads and read length it might be better to choose a different value.\n\n* `max_match_list_size_deviation` defines a threshold where common k-mers are ignored if the number of occurrences exceeds this value. You can increase this to let more common k-mers be included in the search. This will potentially increase time but would likely allow you to align some reads in repetitive regions that would otherwise be unmapped. Decreasing it will give even higher priority to unique k-mers and since the inspected hits will be smaller will help in performance. But as a result, this might lead to losing some seeds and therefore more reads could be left as unmapped.\n\n* `desired_min_number_of_matches` is the lower threshold where the number of better (more unique) hits will result in a seed. Engine will consider less common k-mers until total number of hits exceeds this value (per `hash_block_step`) and attempts to find a seed. If it fails, it'll fall back to all possible hits and search again. Effect of changing this value will be sample specific. If sample contains less data from repetitive regions, lowering the option will result in a speed boost without much loss to accuracy.\n\n### 4.4 Insert Size Estimation\n\nFor paired-end reads, first 10000 pairs will be used to estimate the insert size mean and standard deviation. These statistics will be used in determining window length for seed lookup, compatibility calculations (properness, i.e. `0x02` flag) and pair penalty. Alternatively, If these values are known beforehand they can be provided with `insert_length` and `insert_length_sd` options.",
  "extension_domain": {
    "fhir_extension": {
      "fhir_endpoint": "",
      "fhir_version": "",
      "fhir_resources": {}
    },
    "scm_extension": {
      "scm_repository": "",
      "scm_type": "git",
      "scm_commit": "",
      "scm_path": "",
      "scm_preview": ""
    }
  },
  "description_domain": {
    "keywords": [],
    "xref": [],
    "platform": "Seven Bridges Platform",
    "pipeline_steps": [
      {
        "step_number": "",
        "name": "",
        "description": "",
        "version": "",
        "prerequisite": [],
        "input_list": [],
        "output_list": []
      }
    ]
  },
  "execution_domain": {
    "script": "https://api.sbgenomics.com/v2/apps/soner/bco-demo/gral-0-14-3/0/raw/",
    "script_driver": "Seven Bridges Common Workflow Language Executor",
    "software_prerequisites": [],
    "external_data_endpoints": [],
    "environment_variables": []
  },
  "parametric_domain": [],
  "io_domain": {
    "input_subdomain": [
      {
        "uri": [
          {
            "filename": "",
            "uri": "",
            "access_time": ""
          }
        ]
      }
    ],
    "output_subdomain": [
      {
        "mediatype": "",
        "uri": [
          {
            "uri": "",
            "access_time": ""
          }
        ]
      }
    ]
  },
  "error_domain": {
    "empirical_error": [],
    "algorithmic_error": []
  }
}
